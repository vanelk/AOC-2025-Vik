import "../../../src/libvik/prelude.vik"
import File, FileResult in "../../../src/libvik/file.vik"
import uint_parse, ensure_trailing_char in "common.vik"

// Upper bound log function instead of generalized
fn log10(n: uint): u8 {
    if n == 0 return 0
    if n < 10 return 1
    if n < 100 return 2
    if n < 1000 return 3
    if n < 10000 return 4
    if n < 100000 return 5
    if n < 1000000 return 6
    if n < 10000000 return 7
    if n < 100000000 return 8
    if n < 1000000000 return 9
    return 10
}

fn pow10(exp: u8): uint {
    return when exp {
        0 -> 1
        1 -> 10
        2 -> 100
        3 -> 1000
        4 -> 10000
        5 -> 100000
        6 -> 1000000
        7 -> 10000000
        8 -> 100000000
        9 -> 1000000000
        10 -> 10000000000
        else -> 10000000000
    }
}

fn check_pattern(num: uint, pattern_len: u8, digs_count: u8): bool {
    let base10_pow = pow10(pattern_len)
    let repeated_seq = num % base10_pow
    let partition_size = digs_count / pattern_len
    let working_num = repeated_seq
    
    for _ in (1 as u8)..partition_size {
        working_num = (working_num * base10_pow) + repeated_seq
    }
    
    return num == working_num
}

fn is_invalid_id2(num: uint): bool {
    let digs_count = log10(num)

    // Primes only divisor is 1
    if digs_count is 2 | 3 | 5 | 7 {
        return check_pattern(num, 1, digs_count)
    }

    // Start at 2 as primes is handled above
    let divisor: u8 = 2
    let div_squared = divisor * divisor
    while div_squared <= digs_count {
        if (digs_count % divisor == 0) {
            if check_pattern(num, divisor, digs_count) return true

            let complement = digs_count / divisor
            if complement != divisor {
                if check_pattern(num, complement, digs_count) return true
            }
        }
        divisor += 1
        div_squared = divisor * divisor
    }
    
    return false
}

fn dispatch_is_invalid_id(part: uint, num: uint): bool {
    when part {
        1 -> {
            let digs_count = log10(num)
            if digs_count % 2 != 0 return false
            
            return check_pattern(num, digs_count / 2, digs_count)
        }
        2 -> return is_invalid_id2(num)
        else -> assert(false, "unreachable")
    }
    return false
}

fn count_invalid_ids_in_range(part: uint, start: uint, end: uint): uint {
    let count = 0
    for num in start..=end {
        if dispatch_is_invalid_id(part, num) {
            count += num
        }
    }
    return count
}

fn solve(part: uint, file: [u8]) {
    file = ensure_trailing_char(file, ',')
    let last_comma = -1, last_dash = 0
    let answer = 0
    for i in 0..file.len() {
        when file[i] {
            ',' -> {
                answer += count_invalid_ids_in_range(
                    part,
                    uint_parse(&file[last_comma + 1], last_dash - (last_comma + 1)), 
                    uint_parse(&file[last_dash + 1], i - (last_dash + 1))
                )
                last_comma = i
            }
            '-' -> {
                last_dash = i
            }
            else -> { }
        }
        
    }
    println("answer = %zu", answer)
}

fn main(): i32 {
    let file_path = str.from_cstr("out.txt")
    when File.read_all(&file_path) {
        FileOpenError | FileReadError -> {
            println("error reading file %.*s", file_path.len(), file_path.raw())
        }
        FileOpenSuccess(contents) -> {
            solve(2, contents)
            return 0
        }
    }
}
