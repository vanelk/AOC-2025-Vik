import "../../../src/libvik/prelude.vik"
import File, FileResult in "../../../src/libvik/file.vik"
import u32_parse, ensure_trailing_char in "common.vik"

// Upper bound log function instead of generalized: Basically works till u32.MAX
fn uilog10(n: u32): u32 {
    if n == 0 return 0
    if n < 10 return 1
    if n < 100 return 2
    if n < 1000 return 3
    if n < 10000 return 4
    if n < 100000 return 5
    if n < 1000000 return 6
    if n < 10000000 return 7
    if n < 100000000 return 8
    if n < 1000000000 return 9
    return 10
}

// Fast exponentiation using exponentiation by squaring
fn uipow(b: u32, e: u32): u32 {
    if e == 0 { return 1 }
    if e == 1 { return b }
    
    let answer: u32 = 1
    let base = b
    let exp = e
    
    while exp > 0 {
        if exp % 2 == 1 {
            answer *= base
        }
        base *= base
        exp /= 2
    }
    
    return answer
}

fn is_invalid_id(num: u32): bool {
    let digs_count = uilog10(num)
    if digs_count % 2 == 0 {
        let mpow =  uipow(10, digs_count / 2)

        let pt1 = num / mpow
        let pt2 = num % mpow
        return pt1 == pt2
    }
    return false
}
fn check_pattern(num: u32, pattern_len: u32, digs_count: u32): bool {
    let base10_pow = uipow(10, pattern_len)
    let repeated_seq = num % base10_pow
    let partition_size = digs_count / pattern_len
    let working_num = num / base10_pow
    
    for _ in (1 as u32)..partition_size {
        if (working_num % base10_pow) != repeated_seq {
            return false
        }
        working_num /= base10_pow
    }
    
    return true
}

// Not worth squeezing more perf but; upto sqrt(digs_count) instead of /2 as it technically captures of the divisors of digs_count mathematically
fn is_invalid_id2(num: u32): bool {
    let digs_count = uilog10(num)
    
    for i in (1 as u32)..=(digs_count / 2) {
        if digs_count % i != 0 continue
        if check_pattern(num, i, digs_count) return true
    }
    
    return false
}

fn dispatch_is_invalid_id(part: uint, num: u32): bool {
    when part {
        1 -> return is_invalid_id(num)
        2 -> return is_invalid_id2(num)
        else -> assert(false, "unreachable")
    }
    return false
}

fn count_invalid_ids_in_range(part: uint, start: u32, end: u32): u32 {
    let count: u32 = 0
    for num in start..=end {
        if dispatch_is_invalid_id(part, num) {
            count += num
        }
    }
    return count
}

fn solve(part: uint, file: [u8]) {
    file = ensure_trailing_char(file, ',')
    let last_comma = -1, last_dash = 0
    let answer: u32 = 0
    for i in 0..file.len() {
        when file[i] {
            ',' -> {
                answer += count_invalid_ids_in_range(part,
                    u32_parse(&file[last_comma + 1], last_dash - (last_comma + 1)), 
                    u32_parse(&file[last_dash + 1], i - (last_dash + 1))
                )
                last_comma = i
            }
            '-' -> {
                last_dash = i
            }
            else -> { }
        }
        
    }
    println("answer = %u", answer)
}

fn main(): i32 {
    let file_path = str.from_cstr("out.txt")
    when File.read_all(&file_path) {
        FileOpenError | FileReadError -> {
            println("error reading file %.*s", file_path.len(), file_path.raw())
        }
        FileOpenSuccess(contents) -> {
            solve(2, contents)
            return 0
        }
    }
}
