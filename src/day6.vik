import "../../../src/libvik/prelude.vik"
import File, FileResult in "../../../src/libvik/file.vik"
import uint_parse in "./common.vik"
fn sum(buffer: &uint, len: uint): uint {
    let total = 0
    for i in 0..len {
        total += *buffer.offset(i)
    }
    return total
}

fn apply_operation(op: u8, acc: uint, num: uint): uint {
    return when op {
        '+' -> acc + num
        '*' -> acc * num
        else -> {
            assert(false, "unknown operation %c", op)
            0
        }
    }
}

fn extract_operators_and_dims(file: [u8], ops: &u8, cols: &uint, rows: &uint): uint {
    let count = 0
    let x = file.len() - 1
    while file[x] != '\n' {
        if file[x] is '*' | '+' {
            *ops.offset(count) = file[x]
            count += 1
        }
        x -= 1
    }
    
    *cols = file.len() - x - 1
    *rows = file.len() / (*cols + 1)
    return count
}

fn solve_pt2(file: [u8]): uint {
    let problem_ops: [u8 * 1024]
    let problems_compact: [uint * 1024]

    let cols = 0, rows = 0
    let problems_count = extract_operators_and_dims(file, &problem_ops[0], &cols, &rows)
    
    let working_buffer: [u8 * 1024]
    let wb_len = 0

    let solved_cols = 0
    let first = true
    for col_offset in 0..cols {
        let col = cols - col_offset - 1
        for row in 0..rows {
            let index = row * (cols + 1) + col
            let char = file[index]
            if char is '0'..='9' {
                working_buffer[wb_len] = char
                wb_len += 1
            }
        }
        if wb_len == 0 {
            solved_cols += 1
            first = true
            continue
        }
        let num = uint_parse(&working_buffer[0], wb_len)
        wb_len = 0
        if first {
            problems_compact[solved_cols] = num
            first = false
            continue
        }
        problems_compact[solved_cols] = apply_operation(problem_ops[solved_cols], problems_compact[solved_cols], num)
    }
    return sum(&problems_compact[0], problems_count)
}
fn solve_pt1(file: [u8]): uint {
    // Heurestics; Assuming that we don't exceed that
    let problems_compact: [uint * 1024]
    let problem_ops: [u8 * 1024]
    let last_digit = 0, start_of_num = 0
    let _ = 0, row = 0, col = 0
    let cols = extract_operators_and_dims(file, &problem_ops[0], &_, &_)

    for i in 0..file.len() {
        let char = file[i]
        when char {
            '\n' | ' '-> {
                if last_digit != i - 1 {
                    start_of_num = i + 1
                    continue
                }
                let num = uint_parse(&file[start_of_num], i - start_of_num)
                
                problems_compact[col] = when row {
                    0 -> num 
                    else -> apply_operation(problem_ops[cols - col - 1], problems_compact[col], num)
                }
                
                start_of_num = i + 1
                if char == '\n' {
                    row += 1
                    col = 0
                } else {
                    col += 1
                }
            }
            '0'..='9' -> last_digit = i
            '+' | '*' -> break
            else -> {}
        }
    }

    return sum(&problems_compact[0], cols)
}

fn solve(part: uint, file: [u8]) {
    let answer = when part {
        1 -> solve_pt1(file)
        else -> solve_pt2(file)
    }
    println("answer is %zu", answer)
}

fn main(): i32 {
    let file_path = str.from_cstr("out.txt")
    when File.read_all(&file_path) {
        FileOpenError | FileReadError -> {
            println("error reading file %.*s", file_path.len(), file_path.raw())
        }
        FileOpenSuccess(contents) -> {
            solve(1, contents)
            return 0
        }
    }
}
